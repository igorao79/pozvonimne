'use client'

import { useEffect, useRef } from 'react'
import SimplePeer from 'simple-peer'
import useCallStore from '@/store/useCallStore'
import { createClient } from '@/utils/supabase/client'

const useWebRTC = () => {
  const peerRef = useRef<SimplePeer.Instance | null>(null)
  const signalBufferRef = useRef<Array<{signal: any, from: string}>>([])
  const keepAliveIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const connectionCheckIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const lastKeepAliveRef = useRef<number>(0)
  const reconnectAttemptsRef = useRef<number>(0)
  const supabase = createClient()
  
  const {
    userId,
    targetUserId,
    isInCall,
    isCalling,
    isCallActive,
    isReceivingCall,
    callerId,
    setLocalStream,
    setRemoteStream,
    setPeer,
    setIsCallActive,
    setError,
    endCall,
    setTargetUserId
  } = useCallStore()

  // –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ –∫–∞–∂–¥–æ–º —Ä–µ–Ω–¥–µ—Ä–µ
  console.log(`üéØ [User ${userId?.slice(0, 8)}] useWebRTC render with state:`, {
    isInCall,
    isCalling,
    isCallActive,
    isReceivingCall,
    hasPeer: !!peerRef.current,
    targetUserId: targetUserId?.slice(0, 8),
    callerId: callerId?.slice(0, 8)
  })

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
  const processBufferedSignals = () => {
    const bufferedSignals = signalBufferRef.current
    if (bufferedSignals.length > 0 && peerRef.current && !peerRef.current.destroyed) {
      console.log(`üîÑ [User ${userId?.slice(0, 8)}] Processing ${bufferedSignals.length} buffered signals`)
      
      bufferedSignals.forEach(({ signal, from }, index) => {
        try {
          console.log(`üîÑ [User ${userId?.slice(0, 8)}] Processing buffered signal ${index + 1}/${bufferedSignals.length}: ${signal.type} from ${from.slice(0, 8)}`)
          peerRef.current!.signal(signal)
        } catch (err) {
          console.error(`Error processing buffered signal ${index + 1}:`, err)
        }
      })
      
      // –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
      signalBufferRef.current = []
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] All buffered signals processed and buffer cleared`)
    }
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ keep-alive —Å–∏–≥–Ω–∞–ª–æ–≤
  const startKeepAlive = () => {
    if (keepAliveIntervalRef.current) {
      clearInterval(keepAliveIntervalRef.current)
    }

    console.log(`üíì [User ${userId?.slice(0, 8)}] Starting keep-alive mechanism`)
    
    keepAliveIntervalRef.current = setInterval(() => {
      if (peerRef.current && !peerRef.current.destroyed && targetUserId && isCallActive) {
        try {
          const currentTime = Date.now()
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º keep-alive –ø–∞–∫–µ—Ç —á–µ—Ä–µ–∑ data channel
          if (peerRef.current.connected) {
            peerRef.current.send(JSON.stringify({
              type: 'keep_alive',
              timestamp: currentTime,
              from: userId
            }))
            
            lastKeepAliveRef.current = currentTime
            console.log(`üíì [User ${userId?.slice(0, 8)}] Keep-alive sent at ${new Date(currentTime).toLocaleTimeString()}`)
          } else {
            console.warn(`üíì [User ${userId?.slice(0, 8)}] Peer not connected, skipping keep-alive`)
          }
        } catch (err) {
          console.warn(`üíì [User ${userId?.slice(0, 8)}] Keep-alive error:`, err)
        }
      }
    }, 30000) // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º keep-alive –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ keep-alive
  const stopKeepAlive = () => {
    if (keepAliveIntervalRef.current) {
      clearInterval(keepAliveIntervalRef.current)
      keepAliveIntervalRef.current = null
      console.log(`üíì [User ${userId?.slice(0, 8)}] Keep-alive stopped`)
    }
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  const startConnectionMonitoring = () => {
    if (connectionCheckIntervalRef.current) {
      clearInterval(connectionCheckIntervalRef.current)
    }

    console.log(`üìä [User ${userId?.slice(0, 8)}] Starting connection monitoring`)
    
    connectionCheckIntervalRef.current = setInterval(() => {
      if (peerRef.current && !peerRef.current.destroyed) {
        const pc = (peerRef.current as any)._pc
        
        if (pc) {
          const connectionState = pc.connectionState
          const iceConnectionState = pc.iceConnectionState
          const iceGatheringState = pc.iceGatheringState
          
          console.log(`üìä [User ${userId?.slice(0, 8)}] Connection status:`, {
            connectionState,
            iceConnectionState,
            iceGatheringState,
            connected: peerRef.current.connected,
            lastKeepAlive: lastKeepAliveRef.current ? new Date(lastKeepAliveRef.current).toLocaleTimeString() : 'never'
          })

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
          if (connectionState === 'failed' || iceConnectionState === 'failed') {
            console.error(`üìä [User ${userId?.slice(0, 8)}] Connection failed, attempting reconnection`)
            attemptReconnection()
          } else if (connectionState === 'disconnected' || iceConnectionState === 'disconnected') {
            console.warn(`üìä [User ${userId?.slice(0, 8)}] Connection disconnected, monitoring...`)
            // –ñ–¥–µ–º 10 —Å–µ–∫—É–Ω–¥ –Ω–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å - –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è
            setTimeout(() => {
              if (peerRef.current && !peerRef.current.destroyed) {
                const currentState = (peerRef.current as any)._pc?.connectionState
                if (currentState === 'disconnected' || currentState === 'failed') {
                  console.error(`üìä [User ${userId?.slice(0, 8)}] Connection still disconnected after 10s, attempting reconnection`)
                  attemptReconnection()
                }
              }
            }, 10000)
          }

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π keep-alive (–Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç–∞—Ä—à–µ 2 –º–∏–Ω—É—Ç)
          if (lastKeepAliveRef.current && Date.now() - lastKeepAliveRef.current > 120000) {
            console.warn(`üìä [User ${userId?.slice(0, 8)}] No keep-alive response for 2+ minutes, checking connection...`)
            if (connectionState !== 'connected') {
              attemptReconnection()
            }
          }
        }
      }
    }, 15000) // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
  const stopConnectionMonitoring = () => {
    if (connectionCheckIntervalRef.current) {
      clearInterval(connectionCheckIntervalRef.current)
      connectionCheckIntervalRef.current = null
      console.log(`üìä [User ${userId?.slice(0, 8)}] Connection monitoring stopped`)
    }
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ø—ã—Ç–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
  const attemptReconnection = () => {
    if (reconnectTimeoutRef.current || !isInCall || !targetUserId) {
      return
    }

    const maxRetries = 3
    const currentAttempt = reconnectAttemptsRef.current + 1
    
    if (currentAttempt > maxRetries) {
      console.error(`üîÑ [User ${userId?.slice(0, 8)}] Max reconnection attempts reached, ending call`)
      setError('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ')
      endCall()
      return
    }

    console.log(`üîÑ [User ${userId?.slice(0, 8)}] Attempting reconnection ${currentAttempt}/${maxRetries}`)
    reconnectAttemptsRef.current = currentAttempt

    // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º
    reconnectTimeoutRef.current = setTimeout(() => {
      reconnectTimeoutRef.current = null
      
      if (isInCall && targetUserId) {
        console.log(`üîÑ [User ${userId?.slice(0, 8)}] Reinitializing peer connection`)
        
        // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        if (peerRef.current && !peerRef.current.destroyed) {
          try {
            peerRef.current.destroy()
          } catch (err) {
            console.warn('Error destroying old peer during reconnection:', err)
          }
          peerRef.current = null
        }

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        const wasInitiator = isCalling
        initializePeer(wasInitiator)
      }
    }, 2000 * currentAttempt) // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É —Å –∫–∞–∂–¥–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—á–µ—Ç—á–∏–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
  const resetReconnectionCounter = () => {
    reconnectAttemptsRef.current = 0
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }
  }

  // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ICE —Å–µ—Ä–≤–µ—Ä–æ–≤
  const iceServers = [
    // –û—Å–Ω–æ–≤–Ω—ã–µ –±—ã—Å—Ç—Ä—ã–µ STUN —Å–µ—Ä–≤–µ—Ä—ã Google
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:stun3.l.google.com:19302' },
    { urls: 'stun:stun4.l.google.com:19302' },
    
    // –ù–∞–¥–µ–∂–Ω—ã–µ TURN —Å–µ—Ä–≤–µ—Ä—ã –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Å–µ—Ç–µ–π
    {
      urls: [
        'turn:openrelay.metered.ca:80',
        'turn:openrelay.metered.ca:443',
        'turns:openrelay.metered.ca:443'
      ],
      username: 'openrelayproject',
      credential: 'openrelayproject'
    },
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ TURN —Å–µ—Ä–≤–µ—Ä—ã –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
    {
      urls: [
        'turn:relay.backups.cz',
        'turn:relay.backups.cz:443'
      ],
      username: 'webrtc',
      credential: 'webrtc'
    },
    
    // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ STUN —Å–µ—Ä–≤–µ—Ä—ã
    { urls: 'stun:stun.freeswitch.org' },
    { urls: 'stun:stun.voip.blackberry.com:3478' },
    { urls: 'stun:stun.sipgate.net:3478' },
    { urls: 'stun:stun.ekiga.net' },
    { urls: 'stun:stun.ideasip.com' }
  ]

  const initializePeer = async (isInitiator: boolean) => {
    try {
      // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö peer —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
      if (peerRef.current && !peerRef.current.destroyed) {
        console.log('Peer already exists, destroying old one')
        try {
          peerRef.current.destroy()
        } catch (err) {
          console.warn('Error destroying old peer:', err)
        }
        peerRef.current = null
      }

      console.log('Requesting microphone access...')
      console.log('HTTPS check:', window.location.protocol === 'https:')
      console.log('User agent:', navigator.userAgent)

      // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ –∞—É–¥–∏–æ
      const constraints = {
        video: false,
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          googEchoCancellation: true,
          googAutoGainControl: true,
          googNoiseSuppression: true,
          googHighpassFilter: true,
          googTypingNoiseDetection: true,
          sampleRate: 48000, // –í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∑–≤—É–∫–∞
          sampleSize: 16,
          channelCount: 1, // –ú–æ–Ω–æ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —Ç—Ä–∞—Ñ–∏–∫–∞
          latency: 0.01, // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
          volume: 1.0
        }
      }

      console.log('Requesting media with constraints:', constraints)
      const stream = await navigator.mediaDevices.getUserMedia(constraints)

      console.log('Microphone access granted, stream:', {
        id: stream.id,
        tracks: stream.getTracks().map(track => ({
          kind: track.kind,
          label: track.label,
          enabled: track.enabled,
          muted: track.muted,
          readyState: track.readyState
        }))
      })

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç—Ä–µ–∫–∏ –∞–∫—Ç–∏–≤–Ω—ã
      const audioTracks = stream.getAudioTracks()
      console.log('Audio tracks:', audioTracks.length)
      audioTracks.forEach((track, index) => {
        console.log(`Audio track ${index}:`, {
          enabled: track.enabled,
          muted: track.muted,
          readyState: track.readyState,
          constraints: track.getConstraints(),
          settings: track.getSettings()
        })
      })

      setLocalStream(stream)

      // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è peer connection
      const peer = new SimplePeer({
        initiator: isInitiator,
        trickle: true, // –í–∫–ª—é—á–∞–µ–º trickle ICE –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        stream,
        config: {
          iceServers,
          iceTransportPolicy: 'all',
          bundlePolicy: 'max-bundle',
          rtcpMuxPolicy: 'require',
          iceCandidatePoolSize: 15, // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—É–ª –¥–ª—è –ª—É—á—à–µ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
          // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
          certificates: undefined // –ê–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
        },
        offerOptions: {
          offerToReceiveAudio: true,
          offerToReceiveVideo: false
        },
        answerOptions: {
          offerToReceiveAudio: true,
          offerToReceiveVideo: false
        },
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        allowHalfTrickle: true,
        objectMode: false,
        // –í–∫–ª—é—á–∞–µ–º data channel –¥–ª—è keep-alive
        channelConfig: {
          ordered: true,
          maxRetransmits: 30
        },
        channelName: `datachannel-${userId}-${Date.now()}`
      })

      peer.on('error', (err) => {
        console.error('Peer error:', err)

        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
        if (err instanceof Error) {
          if (err.message.includes('InvalidStateError') ||
              err.message.includes('wrong state') ||
              err.message.includes('already have a remote') ||
              err.message.includes('remote description')) {
            console.log('Ignoring recoverable peer error:', err.message)
            return
          }
        }

        setError('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ' + err.message)
        endCall()
      })

      peer.on('signal', async (data) => {
        try {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ peer –Ω–µ —É–Ω–∏—á—Ç–æ–∂–µ–Ω –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–∫—É—â–µ–º—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—é
          if (peer.destroyed || peer !== peerRef.current) {
            console.log('Peer destroyed or outdated, not sending signal')
            return
          }

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ peer connection
          const peerState = (peer as any)._pc?.connectionState || 'unknown'
          if (peerState === 'closed' || peerState === 'failed') {
            console.log('Peer connection closed/failed, not sending signal')
            return
          }

          // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π targetUserId –∏–∑ store –Ω–∞ –º–æ–º–µ–Ω—Ç –æ—Ç–ø—Ä–∞–≤–∫–∏
          const currentTargetUserId = useCallStore.getState().targetUserId
          
          if (!currentTargetUserId) {
            console.error(`‚ùå [User ${userId?.slice(0, 8)}] Cannot send signal - no targetUserId set!`, {
              originalTargetUserId: targetUserId,
              currentTargetUserId,
              signalType: data.type,
              isReceivingCall: useCallStore.getState().isReceivingCall,
              callerId: useCallStore.getState().callerId
            })
            return
          }

          console.log(`üì§ [User ${userId?.slice(0, 8)}] Sending signal to ${currentTargetUserId.slice(0, 8)}:`, data.type)
          // Send signal to the other user using current targetUserId
          const targetChannel = supabase.channel(`webrtc:${currentTargetUserId}`)
          await targetChannel.subscribe()

          await targetChannel.send({
            type: 'broadcast',
            event: 'webrtc_signal',
            payload: {
              signal: data,
              from: userId
            }
          })
          console.log('Signal sent successfully')
        } catch (err) {
          console.error('Error sending signal:', err)
        }
      })

      peer.on('connect', () => {
        console.log('Peer connected!')
        setIsCallActive(true)
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
        resetReconnectionCounter()
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º keep-alive –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
        startKeepAlive()
        startConnectionMonitoring()
      })

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
      peer.on('iceStateChange', (state) => {
        console.log('ICE state changed:', state)
      })

      peer.on('iceCandidate', (candidate) => {
        console.log('New ICE candidate:', candidate)
      })

      peer.on('signal', (data) => {
        console.log(`üì§ [User ${userId?.slice(0, 8)}] Generated signal:`, data.type, {
          type: data.type,
          hasSdp: !!(data as any).sdp,
          hasCandidate: !!(data as any).candidate,
          targetUser: targetUserId?.slice(0, 8)
        })
      })

      peer.on('stream', (remoteStream) => {
        console.log('Received remote stream:', {
          id: remoteStream.id,
          tracks: remoteStream.getTracks().map(track => ({
            kind: track.kind,
            label: track.label,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState
          }))
        })

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º remote audio tracks
        const remoteAudioTracks = remoteStream.getAudioTracks()
        console.log('Remote audio tracks:', remoteAudioTracks.length)
        remoteAudioTracks.forEach((track, index) => {
          console.log(`Remote audio track ${index}:`, {
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState,
            constraints: track.getConstraints(),
            settings: track.getSettings()
          })

          // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —Ç—Ä–µ–∫–∞
          track.onended = () => console.log(`Remote audio track ${index} ended`)
          track.onmute = () => console.log(`Remote audio track ${index} muted`)
          track.onunmute = () => console.log(`Remote audio track ${index} unmuted`)
        })

        setRemoteStream(remoteStream)
      })

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ data channel
      peer.on('data', (data) => {
        try {
          const message = JSON.parse(data.toString())
          
          if (message.type === 'keep_alive') {
            console.log(`üíì [User ${userId?.slice(0, 8)}] Keep-alive received from ${message.from?.slice(0, 8)} at ${new Date(message.timestamp).toLocaleTimeString()}`)
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –Ω–∞ keep-alive
            if (peerRef.current && !peerRef.current.destroyed && peerRef.current.connected) {
              peerRef.current.send(JSON.stringify({
                type: 'keep_alive_response',
                timestamp: Date.now(),
                originalTimestamp: message.timestamp,
                from: userId
              }))
            }
          } else if (message.type === 'keep_alive_response') {
            console.log(`üíì [User ${userId?.slice(0, 8)}] Keep-alive response received from ${message.from?.slice(0, 8)}`)
            lastKeepAliveRef.current = Date.now()
          }
        } catch (err) {
          console.warn('Error parsing data channel message:', err)
        }
      })

      peer.on('close', () => {
        console.log('Peer connection closed')
        
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º keep-alive –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
        stopKeepAlive()
        stopConnectionMonitoring()
        
        // –ù–µ –≤—ã–∑—ã–≤–∞–µ–º endCall() –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ä–µ–∫—É—Ä—Å–∏–∏
        // endCall() –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω —á–µ—Ä–µ–∑ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏—è –≤ CallInterface
      })

      peerRef.current = peer
      setPeer(peer)

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è peer
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] Peer initialized, checking for buffered signals...`)
      processBufferedSignals()

    } catch (err) {
      console.error('Error initializing peer:', err)

      // –î–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –æ—à–∏–±–æ–∫
      if (err instanceof Error) {
        if (err.name === 'NotAllowedError') {
          setError('–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–ø—Ä–µ—â–µ–Ω. –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞.')
        } else if (err.name === 'NotFoundError') {
          setError('–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞.')
        } else if (err.name === 'NotReadableError') {
          setError('–ú–∏–∫—Ä–æ—Ñ–æ–Ω –∑–∞–Ω—è—Ç –¥—Ä—É–≥–∏–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º.')
        } else if (err.name === 'OverconstrainedError') {
          setError('–ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è.')
        } else if (err.name === 'SecurityError') {
          setError('–¢—Ä–µ–±—É–µ—Ç—Å—è HTTPS –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ.')
        } else if (err.name === 'AbortError') {
          setError('–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω.')
        } else {
          setError(`–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: ${err.message}`)
        }
      } else {
        setError('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É')
      }

      endCall()
    }
  }

  // Listen for WebRTC signals
  useEffect(() => {
    if (!userId) return

    console.log('Setting up WebRTC signal listener for user:', userId)

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    const handleBeforeUnload = () => {
      if (peerRef.current && !peerRef.current.destroyed) {
        try {
          peerRef.current.destroy()
        } catch (err) {
          console.warn('Error destroying peer on page unload:', err)
        }
      }
    }

    window.addEventListener('beforeunload', handleBeforeUnload)

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    const handleVisibilityChange = () => {
      const isHidden = document.hidden
      console.log('Page visibility changed:', { hidden: isHidden, visibilityState: document.visibilityState })

      if (isHidden) {
        console.log('Page hidden during call - maintaining connection')
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
      } else {
        console.log('Page visible again')
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange)

    const webrtcChannel = supabase
      .channel(`webrtc:${userId}`)
      .on('broadcast', { event: 'webrtc_signal' }, (payload) => {
        console.log('üì° Received WebRTC signal:', payload)
        const { signal, from } = payload.payload

        console.log('üì° Signal processing check:', {
          hasPeer: !!peerRef.current,
          peerDestroyed: peerRef.current?.destroyed,
          signalFrom: from,
          expectedFrom: targetUserId,
          signalType: signal?.type,
          shouldProcess: peerRef.current && !peerRef.current.destroyed && from === targetUserId
        })

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–∏–≥–Ω–∞–ª –æ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if (from === targetUserId) {
          // –ï—Å–ª–∏ peer –≥–æ—Ç–æ–≤, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–∏–≥–Ω–∞–ª
          if (peerRef.current && !peerRef.current.destroyed) {
            try {
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ peer connection
              const peerState = (peerRef.current as any)._pc?.connectionState || 'unknown'
              console.log('‚úÖ Processing signal from', from, 'Peer state:', peerState, 'Signal type:', signal.type)

              // –†–∞–∑—Ä–µ—à–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–∏–≥–Ω–∞–ª–æ–≤ –≤ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–ª—è –ª—É—á—à–µ–π –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
              if (peerState === 'closed') {
                console.log('Peer connection closed, ignoring signal')
                return
              }

              // –î–ª—è failed —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–æ–±—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å, –≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–º–æ–∂–µ—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
              if (peerState === 'failed') {
                console.log('Peer connection failed, but trying to process signal for recovery')
              }

              console.log(`üîÑ [User ${userId?.slice(0, 8)}] Processing ${signal.type} signal from ${from.slice(0, 8)}`)
              peerRef.current.signal(signal)
            } catch (err) {
              console.error('Error processing signal:', err)

              // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫
              if (err instanceof Error) {
                if (err.message.includes('destroyed')) {
                  console.log('Peer already destroyed, ignoring signal')
                } else if (err.message.includes('InvalidStateError') || err.message.includes('wrong state')) {
                  console.log('Invalid peer state for signal, ignoring')
                } else if (err.message.includes('already have a remote') || err.message.includes('remote description')) {
                  console.log('Remote description already set, ignoring duplicate signal')
                } else {
                  // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ –ª–æ–≥–∏—Ä—É–µ–º –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                  console.warn('Unexpected peer error:', err.message)
                }
              }
            }
          } else {
            // Peer –Ω–µ –≥–æ—Ç–æ–≤ - –±—É—Ñ–µ—Ä–∏–∑—É–µ–º —Å–∏–≥–Ω–∞–ª –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
            console.log(`üì¶ [User ${userId?.slice(0, 8)}] Buffering ${signal.type} signal from ${from.slice(0, 8)} (peer not ready)`)
            signalBufferRef.current.push({ signal, from })
            console.log(`üì¶ [User ${userId?.slice(0, 8)}] Buffer size: ${signalBufferRef.current.length}`)
          }
        } else {
          console.log('Ignoring signal - wrong sender:', {
            from: from?.slice(0, 8),
            expectedFrom: targetUserId?.slice(0, 8)
          })
        }
      })
      .subscribe()

    return () => {
      console.log('Cleaning up WebRTC signal listener')
      // –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤ –ø—Ä–∏ —Å–º–µ–Ω–µ targetUserId –∏–ª–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
      if (signalBufferRef.current.length > 0) {
        console.log(`üóëÔ∏è [User ${userId?.slice(0, 8)}] Clearing signal buffer (${signalBufferRef.current.length} signals)`)
        signalBufferRef.current = []
      }
      supabase.removeChannel(webrtcChannel)
      window.removeEventListener('beforeunload', handleBeforeUnload)
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [userId, targetUserId, supabase])

  // Initialize peer when starting a call (—Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø—Ä–∏–Ω—è—Ç–∏—è –∑–≤–æ–Ω–∫–∞)
  useEffect(() => {
    console.log(`üîç [User ${userId?.slice(0, 8)}] Caller peer initialization check:`, {
      isInCall,
      isCalling,
      isCallActive,
      hasPeer: !!peerRef.current,
      originalCondition: isInCall && isCalling && !peerRef.current,
      newCondition: isInCall && isCalling && isCallActive && !peerRef.current,
      targetUserId: targetUserId?.slice(0, 8)
    })
    
    // Caller –¥–æ–ª–∂–µ–Ω –∂–¥–∞—Ç—å –ø—Ä–∏–Ω—è—Ç–∏—è –∑–≤–æ–Ω–∫–∞ (isCallActive = true)
    if (isInCall && isCalling && isCallActive && !peerRef.current) {
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] Initializing peer as caller (call accepted)`)
      initializePeer(true) // Caller is initiator
    } else if (isInCall && isCalling && !isCallActive) {
      console.log(`‚è≥ [User ${userId?.slice(0, 8)}] Caller waiting for call acceptance...`)
    }
  }, [isInCall, isCalling, isCallActive])

  // Initialize peer when receiving call
  useEffect(() => {
    console.log(`üîç [User ${userId?.slice(0, 8)}] Receiver peer initialization check:`, {
      isInCall,
      isCallActive,
      isCalling,
      isReceivingCall,
      hasPeer: !!peerRef.current,
      callerId: callerId?.slice(0, 8),
      targetUserId: targetUserId?.slice(0, 8),
      conditions: {
        original: isInCall && isCallActive && !isCalling && !peerRef.current,
        simplified: isInCall && !isCalling && !peerRef.current,
        new: isReceivingCall && !peerRef.current
      }
    })
    
    // –ù–æ–≤–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º peer —Å—Ä–∞–∑—É –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–≤–æ–Ω–∫–∞
    if (isReceivingCall && !peerRef.current && callerId) {
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] Initializing peer as receiver (on incoming call)`)
      console.log(`üéØ [User ${userId?.slice(0, 8)}] Setting targetUserId to ${callerId.slice(0, 8)} before peer init`)
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º targetUserId –∫–∞–∫ callerId –°–ù–ê–ß–ê–õ–ê
      setTargetUserId(callerId)
      
      // –î–∞–µ–º –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
      setTimeout(() => {
        if (!peerRef.current) {
          console.log(`üéØ [User ${userId?.slice(0, 8)}] Delayed peer initialization as receiver`)
          initializePeer(false) // Receiver is not initiator
        }
      }, 50)
    } 
    // –û–°–ù–û–í–ù–û–ô Fallback: –µ—Å–ª–∏ –≤ –∑–≤–æ–Ω–∫–µ, –ù–ï caller, –∏ –Ω–µ—Ç peer - —ç—Ç–æ receiver!
    else if (isInCall && !isCalling && isCallActive && !peerRef.current && targetUserId) {
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] Initializing peer as receiver (main fallback - call active)`)
      initializePeer(false) // Receiver is not initiator
    }
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π fallback: –ø—Ä–æ—Å—Ç–æ –≤ –∑–≤–æ–Ω–∫–µ –∏ –Ω–µ caller
    else if (isInCall && !isCalling && !peerRef.current) {
      console.log(`‚úÖ [User ${userId?.slice(0, 8)}] Initializing peer as receiver (simple fallback)`)
      initializePeer(false) // Receiver is not initiator
    } else {
      console.log(`‚ùå [User ${userId?.slice(0, 8)}] Receiver peer initialization skipped`)
    }
  }, [isInCall, isCalling, isCallActive, isReceivingCall, callerId || '', targetUserId || ''])

  // Cleanup on unmount or call end
  useEffect(() => {
    return () => {
      console.log('üßπ useWebRTC: Starting cleanup on unmount')
      
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –∏ —Ç–∞–π–º–∞—É—Ç—ã
      stopKeepAlive()
      stopConnectionMonitoring()
      resetReconnectionCounter()
      
      if (peerRef.current && !peerRef.current.destroyed) {
        try {
          console.log('üßπ useWebRTC: Cleaning up peer connection')

          // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥, —á—Ç–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è
          const peerToDestroy = peerRef.current
          peerRef.current = null

          // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
          setTimeout(() => {
            if (peerToDestroy && !peerToDestroy.destroyed) {
              peerToDestroy.destroy()
            }
          }, 100)
        } catch (err) {
          console.log('üßπ useWebRTC: Peer cleanup error:', err)
        }
      }
    }
  }, [])

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ peer –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–≤–æ–Ω–∫–∞
  useEffect(() => {
    if (!isInCall && peerRef.current) {
      console.log(`üßπ [User ${userId?.slice(0, 8)}] Call ended, force cleanup peer`)
      
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
      stopKeepAlive()
      stopConnectionMonitoring()
      resetReconnectionCounter()
      
      try {
        if (!peerRef.current.destroyed) {
          peerRef.current.destroy()
        }
      } catch (err) {
        console.log('üßπ Force cleanup error:', err)
      }
      peerRef.current = null
    }
  }, [isInCall])

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è peer –¥–ª—è receiver
  useEffect(() => {
    const forceReceiverPeerInit = setTimeout(() => {
      if (isInCall && !isCalling && !peerRef.current && targetUserId) {
        console.log(`üîÑ [User ${userId?.slice(0, 8)}] FORCE initializing peer as receiver after 2s delay`)
        initializePeer(false)
      }
    }, 2000)

    return () => clearTimeout(forceReceiverPeerInit)
  }, [isInCall, isCalling, targetUserId || ''])

  return {
    peer: peerRef.current
  }
}

export default useWebRTC
